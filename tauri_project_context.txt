LLM CONTEXT FILE FOR TAURI PROJECT
GENERATED BY SCRIPT ON: Tuesday 13 May 2025 08:48:43 PM IST

IMPORTANT: This file contains concatenated source code from the project.
Review it carefully for any sensitive information (API keys, passwords,
confidential algorithms, personal data, etc.) BEFORE sharing it with any
Large Language Model or third party.

--- START FILE: README.md ---
# CP-Assist

CP-Assist is a comprehensive desktop application designed to streamline your competitive programming workflow, integrating with popular tools to automate test case management, code execution, and solution submission.

## Table of Contents
- [App Preview](#app-preview)
- [Features](#features)
- [Installation](#installation)
- [Usage](#usage)
- [Configuration](#configuration)

## App Preview


![alt text](https://github.com/veryshyjelly/cp-assist/blob/main/cp-assist-shot.png?raw=true)

https://github.com/user-attachments/assets/516eacd3-817e-4e87-bcbf-0817f914553f

- **Test Case Handling**: Automated collection and management of test cases
- **Code Execution & Judging**: Local testing environment with verdict generation
- **Language Support**: Multi-language compatibility with customizable configurations
- **Submission System**: Direct integration with online judges for solution submission

## Installation

### Prerequisites
- [Competitive Companion](https://github.com/jmerle/competitive-companion) browser extension
- [CP-Submit](https://github.com/tsycho/cp-submit) for submission integration

### Linux
- **AppImage**: [Download](https://github.com/veryshyjelly/cp-assist/releases/download/v0.2.1/cp-assist_0.2.1_amd64.AppImage)
- **Arch Linux**: [.tar file](https://github.com/veryshyjelly/cp-assist/releases/download/v0.2.1/cp-assist-0.2.1-1-x86_64.pkg.tar.zst)
- **Debian/Ubuntu**: [.deb file](https://github.com/veryshyjelly/cp-assist/releases/download/v0.2.1/cp-assist_0.2.1_amd64.deb)
- **Red Hat/Fedora**: [.rpm file](https://github.com/veryshyjelly/cp-assist/releases/download/v0.2.1/cp-assist-0.2.1-1.x86_64.rpm)

### Windows
- **MSI Installer**: [Download](https://github.com/veryshyjelly/cp-assist/releases/download/v0.2.1/cp-assist_0.2.1_x64_en-US.msi)
- **Setup EXE**: [Download](https://github.com/veryshyjelly/cp-assist/releases/download/v0.2.1/cp-assist_0.2.1_x64-setup.exe)

## Usage

1. **Getting Problems**: Navigate to a problem on a supported online judge and use Competitive Companion to send it to CP-Assist
2. **Solving & Testing**: Write your solution and test against provided test cases
3. **Submitting**: Submit your solution directly to the online judge

## Configuration

CP-Assist can be configured through the Settings menu to customize languages, editor preferences, and appearance.


--- END FILE: README.md ---


--- START FILE: package.json ---
{
  "name": "cp-assist",
  "private": true,
  "version": "0.2.1",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "tauri": "tauri"
  },
  "dependencies": {
    "@mantine/core": "^7.12.0",
    "@mantine/hooks": "^7.12.0",
    "@mantine/modals": "^7.12.0",
    "@mantine/notifications": "^7.12.0",
    "@tabler/icons-react": "^3.12.0",
    "@tauri-apps/api": "2.0.0-rc.2",
    "@tauri-apps/plugin-dialog": "2.0.0-rc.0",
    "@tauri-apps/plugin-http": "2.0.0-rc.1",
    "@tauri-apps/plugin-shell": "2.0.0-rc.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1"
  },
  "devDependencies": {
    "@tauri-apps/cli": "2.0.0-rc.5",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.1",
    "autoprefixer": "^10.4.20",
    "postcss": "^8.4.41",
    "tailwindcss": "^3.4.9",
    "typescript": "^5.5.4",
    "vite": "^5.4.0"
  }
}
--- END FILE: package.json ---


--- START FILE: vite.config.ts ---
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

// @ts-expect-error process is a nodejs global
const host = process.env.TAURI_DEV_HOST;

// https://vitejs.dev/config/
export default defineConfig(async () => ({
  plugins: [react()],

  // Vite options tailored for Tauri development and only applied in `tauri dev` or `tauri build`
  //
  // 1. prevent vite from obscuring rust errors
  clearScreen: false,
  // 2. tauri expects a fixed port, fail if that port is not available
  server: {
    port: 1420,
    strictPort: true,
    host: host || false,
    hmr: host
      ? {
          protocol: "ws",
          host,
          port: 1421,
        }
      : undefined,
    watch: {
      // 3. tell vite to ignore watching `src-tauri`
      ignored: ["**/src-tauri/**"],
    },
  },
}));

--- END FILE: vite.config.ts ---


--- START FILE: tsconfig.json ---
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}

--- END FILE: tsconfig.json ---


--- START FILE: postcss.config.js ---
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

--- END FILE: postcss.config.js ---


--- START FILE: tailwind.config.js ---
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
--- END FILE: tailwind.config.js ---


--- START FILE: src-tauri/tauri.conf.json ---
{
  "productName": "cp-assist",
  "version": "0.2.1",
  "identifier": "com.cpgawd.dev",
  "build": {
    "beforeDevCommand": "pnpm dev",
    "devUrl": "http://localhost:1420",
    "beforeBuildCommand": "pnpm build",
    "frontendDist": "../dist"
  },
  "app": {
    "windows": [
      {
        "decorations": false,
        "width": 600,
        "height": 450,
        "transparent": true,
        "skipTaskbar": true
      }
    ],
    "security": {
      "csp": null
    }
  },
  "bundle": {
    "active": true,
    "targets": "all",
    "icon": [
      "icons/icon.png",
      "icons/icon.ico"
    ],
    "resources": [
      "Languages.toml"
    ]
  }
}

--- END FILE: src-tauri/tauri.conf.json ---


--- START FILE: src-tauri/Cargo.toml ---
[package]
name = "cp-assist"
version = "0.2.1"
description = "A Competitive Programming assistant"
authors = ["Ayush Biswas"]
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
name = "cp_lib"
crate-type = ["lib", "cdylib", "staticlib"]

[build-dependencies]
tauri-build = { version = "2.0.0-rc", features = [] }

[dependencies]
tauri = { version = "2.0.0-rc", features = [] }
tauri-plugin-shell = "2.0.0-rc"
serde = { version = "1", features = ["derive"] }
serde_json = "1.0.127"
tauri-plugin-dialog = "2.0.0-rc.0"
actix-web = "4.9.0"
tauri-plugin-http = "2.0.0-rc.0"
toml = { version = "0.8.19", features = ["preserve_order"] }
wait-timeout = "0.2.0"
open = "5.3.0"
boa_engine = "0.20.0"

[dependencies.uuid]
version = "1.10.0"
features = [
    "v4",       # Lets you generate random UUIDs
    "fast-rng", # Use a faster (but still sufficiently random) RNG
]

[target.'cfg(not(any(target_os = "android", target_os = "ios")))'.dependencies]
tauri-plugin-single-instance = "2.0.0-rc.0"

[profile.dev]
incremental = true # Compile your binary in smaller steps.

[profile.release]
codegen-units = 1 # Allows LLVM to perform better optimization.
lto = true        # Enables link-time-optimizations.
opt-level = 3     # Prioritizes small binary size. Use `3` if you prefer speed.
panic = "abort"   # Higher performance by disabling panic handlers.
strip = true      # Ensures debug symbols are removed.

--- END FILE: src-tauri/Cargo.toml ---


--- START FILE: src-tauri/build.rs ---
fn main() {
    tauri_build::build()
}

--- END FILE: src-tauri/build.rs ---


--- START FILE: src-tauri/src/config.rs ---
use boa_engine::Source;
use serde::{Deserialize, Serialize};
use std::fs;
use std::io::Write;
use std::path::PathBuf;
use std::sync::Mutex;
use std::{collections::HashMap, path::Path};
use tauri::State;

use crate::utils::{extract_code_block, ResultTrait};
use crate::{utils::resolve_path, AppState, Problem};

#[derive(Default, Debug, Serialize, Deserialize, Clone)]
pub struct Config {
    pub author: String,
    pub code: Code,
    pub include: HashMap<String, String>,
    pub editor: String,
}

#[derive(Default, Debug, Serialize, Deserialize, Clone)]
pub struct Code {
    pub filename: String,
    pub template: String,
    pub modifier: String,
}

impl Config {
    pub fn get_filename(&self, problem: &Problem) -> Result<String, String> {
        let mut context = boa_engine::Context::default();
        context
            .eval(Source::from_bytes(&self.code.filename))
            .map_to_string()?;

        Ok(context
            .eval(Source::from_bytes(&format!(
                "filename({}, {})",
                problem.title, problem.url
            )))
            .map_to_string_mess("error while evaluating filename")?
            .as_string()
            .unwrap()
            .to_std_string_escaped())
    }

    pub fn get_file_path(&self, problem: &Problem, dir: &Path) -> Result<PathBuf, String> {
        Ok(resolve_path(dir, &self.get_filename(problem)?))
    }

    fn get_included_files(&self, dir: &Path) -> Result<HashMap<String, String>, String> {
        self.include
            .clone()
            .into_iter()
            .map(|(key, value)| {
                let path = resolve_path(dir, &value);
                match fs::read_to_string(&path) {
                    Ok(content) => Ok((key, content)),
                    Err(e) => Err(format!("Failed to read file {:?}: {}", path, e)),
                }
            })
            .collect()
    }

    pub fn get_template(&self, dir: &Path) -> String {
        let template_path = resolve_path(dir, &self.code.template);
        match fs::read_to_string(template_path) {
            Ok(content) => content,
            Err(e) => {
                eprintln!("Error reading template file: {}", e);
                String::new()
            }
        }
    }

    pub fn get_final_code(&self, problem: &Problem, dir: &Path) -> Result<String, String> {
        // Read source code
        let source_code = fs::read_to_string(self.get_file_path(problem, dir)?).map_to_string()?;
        let source_code = extract_code_block(&source_code);

        // Get included files content
        let included_files = self.get_included_files(dir)?;
        // Create JS context
        let mut context = boa_engine::Context::default();
        context
            .eval(Source::from_bytes(self.code.modifier.as_bytes()))
            .map_to_string()?;

        // Prepare JS object for included files
        let includes_js = included_files
            .iter()
            .map(|(k, v)| format!("\"{}\": `{}`", k, v.replace('`', "\\`")))
            .collect::<Vec<String>>()
            .join(", ");

        // Prepare JS call to modifier function
        let js_call = format!(
            "modify(`{}`, {{ {} }})",
            source_code.replace('`', "\\`"),
            includes_js
        );

        // Evaluate the modifier call
        match context.eval(Source::from_bytes(js_call.as_bytes())) {
            Ok(result) => match result.as_string() {
                Some(s) => Ok(s.to_std_string_escaped()),
                None => Err("invaild value produced by modifier script".into()),
            },
            Err(e) => Err(format!("{e}")),
        }
    }
}

#[tauri::command]
pub fn read_config(state: State<'_, Mutex<AppState>>) -> Result<(), String> {
    let mut state = state.lock().unwrap();
    let mut path = state.directory.clone();
    path.push("config.toml");

    let config: Config = if path.exists() {
        let content =
            fs::read_to_string(&path).map_err(|e| format!("Error reading {:?}: {}", path, e))?;
        toml::from_str(&content).map_err(|e| format!("Error parsing config.toml: {}", e))?
    } else {
        // File doesn't exist: create with default content
        let default_config = Config::default();
        let toml_str = toml::to_string_pretty(&default_config)
            .map_err(|e| format!("Error serializing default config: {}", e))?;

        let mut file =
            fs::File::create(&path).map_err(|e| format!("Error creating config.toml: {}", e))?;
        file.write_all(toml_str.as_bytes())
            .map_err(|e| format!("Error writing config.toml: {}", e))?;

        default_config
    };

    state.config = config;

    Ok(())
}

--- END FILE: src-tauri/src/config.rs ---


--- START FILE: src-tauri/src/info.rs ---
use crate::judge::Verdict;
use crate::WINDOW;
use actix_web::{post, web, HttpResponse, Responder};
use serde::{Deserialize, Serialize};
use tauri::Emitter;

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Info {
    name: String,
    group: String,
    url: String,
    interactive: bool,
    memory_limit: usize, // mb
    time_limit: usize,   // ms
    tests: Vec<Test>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Test {
    input: String,
    output: String,
}

#[derive(Deserialize, Serialize, Clone, Default)]
pub struct Problem {
    pub title: String,
    pub url: String,
    pub memory_limit: usize,
    pub time_limit: usize,
}

impl Test {
    pub fn get_verdict(&self) -> Verdict {
        Verdict {
            answer: self.output.clone(),
            input: self.input.clone(),
            output: "".into(),
            memory: 0.0,
            time: 0.0,
            status_id: 0,
            status: "NA".into(),
        }
    }
}

impl Info {
    pub fn get_problem(&self) -> Problem {
        Problem {
            title: self.name.clone(),
            memory_limit: self.memory_limit,
            time_limit: self.time_limit,
            url: self.url.clone(),
        }
    }

    pub fn get_verdicts(&self) -> Vec<Verdict> {
        self.tests.iter().map(|x| x.get_verdict()).collect()
    }
}

#[post("/")]
pub async fn get_info(req_body: web::Json<Info>) -> impl Responder {
    let window = WINDOW.get().expect("window-is-unavailable");
    window.emit("set-problem", req_body.get_problem()).unwrap();
    window
        .emit("set-verdicts", req_body.get_verdicts())
        .unwrap();
    HttpResponse::Ok()
}

--- END FILE: src-tauri/src/info.rs ---


--- START FILE: src-tauri/src/judge.rs ---
use crate::state::AppState;
use crate::utils::*;
use crate::Language;
use serde::{Deserialize, Serialize};
use std::fs::{self, create_dir_all, remove_dir_all};
use std::io::Write;
use std::path::Path;
use std::process::{Command, Stdio};
use std::sync::Mutex;
use tauri::{Emitter, State};
use uuid::Uuid;

// Windows-specific imports
#[cfg(windows)]
use std::os::windows::process::CommandExt;

#[cfg(windows)]
const CREATE_NO_WINDOW: u32 = 0x08000000; // Prevents opening a new window

#[derive(Serialize, Deserialize, Clone, Default)]
pub struct Verdict {
    pub input: String,
    pub output: String,
    pub answer: String,
    pub status_id: usize,
    pub status: String,
    pub time: f32,
    pub memory: f32,
}

#[tauri::command]
pub async fn test(
    app_state: State<'_, Mutex<AppState>>,
    handle: tauri::AppHandle,
) -> Result<(), String> {
    let state = app_state.lock().unwrap();

    // creating a temporary directory
    let mut dir = std::env::temp_dir();
    dir.push(Uuid::new_v4().to_string());

    let language = state.get_language()?;

    let mut file_path = dir.clone();
    file_path.push(&language.source_file);

    let source_file = state
        .config
        .get_final_code(&state.problem, &state.directory)?;

    // copy the final code into the temporary directory
    create_dir_all(&dir).map_to_string()?;
    fs::write(file_path, source_file).map_to_string()?;

    let mut verdicts = state.verdicts.clone();
    for v in &mut verdicts {
        v.status = "Compiling".into();
        v.status_id = 1;
    }
    handle.emit("set-verdicts", &verdicts).map_to_string()?;

    // First try to compiler and if compilation error occurs then return
    if let Err(e) = compile(&language, &dir) {
        for v in &mut verdicts {
            v.output = e.clone();
            v.status = "Compilation Error".into();
            v.status_id = 6;
        }
        handle.emit("set-verdicts", &verdicts).map_to_string()?;
    } else {
        for v in &mut verdicts {
            v.status = "Running".into();
            v.status_id = 2;
        }
        handle.emit("set-verdicts", &verdicts).map_to_string()?;

        let verdicts = run_all(&language, &dir, verdicts)?;
        handle.emit("set-verdicts", &verdicts).map_to_string()?;
    }

    remove_dir_all(dir).map_to_string()?;

    Ok(())
}

fn compile(language: &Language, dir: &Path) -> Result<bool, String> {
    if language.compiler_cmd.is_empty() {
        // If there is no compilation step then nothing to do
        return Ok(true);
    }

    #[cfg(windows)]
    let output = Command::new(&language.compiler_cmd)
        .current_dir(dir)
        .args(&language.compiler_args)
        .creation_flags(CREATE_NO_WINDOW)
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .output()
        .map_to_string()?;

    #[cfg(not(windows))]
    let output = Command::new(&language.compiler_cmd)
        .current_dir(dir)
        .args(&language.compiler_args)
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .output()
        .map_to_string()?;

    if output.status.success() {
        Ok(true)
    } else {
        Err(String::from_utf8_lossy(&output.stderr).to_string()
            + String::from_utf8_lossy(&output.stdout).to_string().as_str())
    }
}

fn run_all(
    language: &Language,
    dir: &Path,
    verdicts: Vec<Verdict>,
) -> Result<Vec<Verdict>, String> {
    let mut res = vec![];
    for v in verdicts {
        res.push(run(language, dir, v)?);
    }
    Ok(res)
}

fn run(language: &Language, dir: &Path, mut verdict: Verdict) -> Result<Verdict, String> {
    #[cfg(debug_assertions)]
    println!("dir: {}", dir.to_str().unwrap());
    let run_cmd = &language.run_cmd;

    #[cfg(target_os = "windows")]
    {
        if !language.run_cmd_win.is_empty() {
            run_cmd = &language.run_cmd_win;
        }
    }

    #[cfg(debug_assertions)]
    println!("run_cmd: {}", run_cmd);

    // Create command with platform-specific options
    #[cfg(windows)]
    let mut child = Command::new(resolve_path(dir, run_cmd))
        .current_dir(dir)
        .args(&language.run_args)
        .creation_flags(CREATE_NO_WINDOW)
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .map_to_string()?;

    #[cfg(not(windows))]
    let mut child = Command::new(resolve_path(dir, run_cmd))
        .current_dir(dir)
        .args(&language.run_args)
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .map_to_string()?;

    if let Some(mut stdin) = child.stdin.take() {
        stdin.write_all(verdict.input.as_bytes()).map_to_string()?;
    }

    let output = child.wait_with_output().map_to_string();

    match output {
        Ok(sucess) => {
            if !sucess.status.success() {
                verdict.output = String::from_utf8_lossy(&sucess.stderr).into();
                verdict.status_id = 11;
                verdict.status = "Runtime Error (NZEC)".into();
            } else {
                verdict.output = String::from_utf8_lossy(&sucess.stdout).to_string();
                if check(&verdict.answer, &verdict.output) {
                    verdict.status = "Accepted".into();
                    verdict.status_id = 3;
                } else {
                    verdict.status = "Wrong Answer".into();
                    verdict.status_id = 4;
                }
            }
        }
        Err(runtime_err) => {
            verdict.output = runtime_err;
            verdict.status_id = 7;
            verdict.status = "Runtime Error (SIGABRT)".into();
        }
    }

    Ok(verdict)
}

fn check(output: &String, answer: &String) -> bool {
    output
        .trim()
        .split('\n')
        .map(|x| x.trim())
        .zip(answer.trim().split('\n').map(|x| x.trim()))
        .all(|(x, y)| x == y)
}

--- END FILE: src-tauri/src/judge.rs ---


--- START FILE: src-tauri/src/language.rs ---
use crate::{state::AppState, utils::ResultTrait};
use serde::{Deserialize, Serialize};
use std::fs;
use std::{
    collections::HashMap,
    process::{Command, Stdio},
    sync::Mutex,
    time::Duration,
};
use tauri::{path::BaseDirectory, Manager, State};
use wait_timeout::ChildExt;

#[cfg(windows)]
use std::os::windows::process::CommandExt;

#[cfg(windows)]
const CREATE_NO_WINDOW: u32 = 0x08000000; // Prevents opening a new window

#[derive(Serialize, Deserialize, Clone, Default)]
#[serde(default)]
pub struct Language {
    pub id: usize,
    pub cf_id: usize,
    pub name: String,
    #[serde(skip_serializing)]
    pub source_file: String,
    #[serde(skip_serializing)]
    pub compiler_cmd: String,
    #[serde(skip_serializing)]
    pub compiler_args: Vec<String>,
    #[serde(skip_serializing)]
    pub run_cmd: String,
    #[serde(skip_serializing)]
    pub run_cmd_win: String,
    #[serde(skip_serializing)]
    pub run_args: Vec<String>,
    #[serde(skip_serializing)]
    pub check_args: Vec<String>,
    #[serde(skip_serializing)]
    pub comment: String,
}

impl Language {
    pub fn check(&self) -> bool {
        let cmd = if self.compiler_cmd.is_empty() {
            &self.run_cmd
        } else {
            &self.compiler_cmd
        };

        #[cfg(windows)]
        let result = Command::new(cmd)
            .args(&self.check_args)
            .creation_flags(CREATE_NO_WINDOW)
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn();

        #[cfg(unix)]
        let result = Command::new(cmd)
            .args(&self.check_args)
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn();

        if let Ok(mut o) = result {
            let _ = o.wait_timeout(Duration::from_secs(2));
            true
        } else {
            false
        }
    }
}

#[tauri::command]
pub async fn get_languages(
    state: State<'_, Mutex<AppState>>,
    handle: tauri::AppHandle,
) -> Result<Vec<Language>, String> {
    if state.lock().unwrap().languages.is_empty() {
        let path = handle
            .path()
            .resolve("Languages.toml", BaseDirectory::Config)
            .map_to_string_mess("Failed to resolve config path")?;

        // If config file doesn't exist, copy from resources
        if !path.exists() {
            let resource_path = handle
                .path()
                .resolve("Languages.toml", BaseDirectory::Resource)
                .map_to_string_mess("Languages.toml not found in resources")?;

            // Create config directory if needed
            if let Some(parent) = path.parent() {
                fs::create_dir_all(parent)
                    .map_to_string_mess("Failed to create config directory")?;
            }

            fs::copy(&resource_path, &path)
                .map_to_string_mess("Failed to copy to config directory")?;
        }

        // Read from config directory
        let content =
            fs::read_to_string(&path).map_to_string_mess(&format!("Error reading {:?}", path))?;
        let languages: HashMap<String, Language> =
            toml::from_str(&content).map_to_string_mess("Error parsing Languages.toml")?;

        state.lock().unwrap().languages = languages.into_iter().filter(|(_, v)| v.check()).collect()
    }

    let languages_map = state.lock().unwrap().languages.clone();

    let mut languages = vec![];
    for (id, mut language) in languages_map {
        language.id = id.parse().unwrap();
        languages.push(language);
    }

    Ok(languages)
}

#[tauri::command]
pub fn get_language(state: State<'_, Mutex<AppState>>) -> usize {
    state.lock().unwrap().language_id
}

#[tauri::command]
pub fn set_language(language_id: usize, state: State<'_, Mutex<AppState>>) {
    state.lock().unwrap().language_id = language_id
}

--- END FILE: src-tauri/src/language.rs ---


--- START FILE: src-tauri/src/lib.rs ---
mod config;
mod info;
mod judge;
mod language;
mod state;
mod submit;
mod utils;

use actix_web::{web, App, HttpServer};
use config::read_config;
use info::*;
use judge::*;
use language::*;
use state::*;
use std::sync::{Mutex, OnceLock};
use submit::*;
use tauri::{AppHandle, Manager, WebviewWindow};

pub static WINDOW: OnceLock<WebviewWindow> = OnceLock::new();

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .plugin(tauri_plugin_http::init())
        .setup(|app| {
            let window = app.get_webview_window("main").unwrap();

            _ = WINDOW.set(window);

            let web_state = web::Data::new(WebState {
                sol: Mutex::new(None),
            });

            tauri::async_runtime::spawn(
                HttpServer::new(move || {
                    App::new()
                        .app_data(web_state.clone())
                        .service(get_info)
                        .service(get_submit)
                        .service(post_submit)
                })
                .bind(("127.0.0.1", 27121))?
                .run(),
            );

            let dir = app.path().app_config_dir().unwrap();
            let state = AppState::from_dir(dir).unwrap();
            app.manage(Mutex::new(state));
            Ok(())
        })
        .plugin(tauri_plugin_dialog::init())
        .plugin(tauri_plugin_shell::init())
        .plugin(tauri_plugin_single_instance::init(|app, _args, _cwd| {
            let _ = show_window(app);
        }))
        .invoke_handler(tauri::generate_handler![
            get_directory,
            set_directory,
            set_language,
            get_language,
            get_languages,
            set_problem,
            get_problem,
            set_verdicts,
            get_verdicts,
            create_file,
            read_config,
            save_state,
            submit_solution,
            test,
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}

fn show_window(app: &AppHandle) {
    let windows = app.webview_windows();

    if let Some(window) = windows.values().next() {
        window.set_skip_taskbar(false).unwrap(); // ✅ Ensure it appears in taskbar
        window.show().unwrap(); // ✅ Make sure the window is visible
        window.set_focus().unwrap(); // ✅ Bring it to front
    } else {
        panic!("Sorry, no window found");
    }
}

--- END FILE: src-tauri/src/lib.rs ---


--- START FILE: src-tauri/src/main.rs ---
// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

fn main() {
    cp_lib::run()
}

--- END FILE: src-tauri/src/main.rs ---


--- START FILE: src-tauri/src/state.rs ---
use crate::config::Config;
use crate::info::Problem;
use crate::judge::Verdict;
use crate::utils::*;
use crate::Language;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs::{create_dir_all, File};
use std::io::{BufReader, Write};
use std::ops::Deref;
use std::path::PathBuf;
use std::str::FromStr;
use std::sync::Mutex;
use std::time;
use tauri::{Manager, State};

// Windows-specific imports
#[cfg(windows)]
use std::os::windows::process::CommandExt;

#[cfg(windows)]
const CREATE_NO_WINDOW: u32 = 0x08000000; // Prevents opening a new window

#[derive(Default, Serialize, Deserialize, Clone)]
pub struct AppState {
    pub directory: PathBuf,
    pub language_id: usize,
    #[serde(default, skip_serializing)]
    pub config: Config,
    #[serde(default, skip_serializing)]
    pub languages: HashMap<String, Language>,
    #[serde(default, skip_serializing)]
    pub problem: Problem,
    #[serde(default, skip_serializing)]
    pub verdicts: Vec<Verdict>,
}

impl AppState {
    pub fn from_dir(dir: PathBuf) -> std::io::Result<Self> {
        create_dir_all(&dir)?;

        let mut file_path = dir.clone();
        file_path.push("cp_state.json");

        let res = if file_path.exists() {
            serde_json::from_reader(BufReader::new(File::open(file_path)?))?
        } else {
            let mut f = File::create(file_path)?;
            let state = AppState::default();
            f.write_fmt(format_args!("{}", serde_json::to_string(&state)?))?;
            state
        };

        Ok(res)
    }

    pub fn get_language(&self) -> Result<Language, String> {
        let language = self
            .languages
            .get(&self.language_id.to_string())
            .ok_or("language not found in langauges")?
            .clone();
        Ok(language)
    }
}

#[tauri::command]
pub fn get_directory(state: State<'_, Mutex<AppState>>) -> String {
    state.lock().unwrap().directory.to_str().unwrap().into()
}

#[tauri::command]
pub fn set_directory(directory: String, state: State<'_, Mutex<AppState>>) -> Result<(), String> {
    let dir = PathBuf::from_str(&directory).map_to_string()?;
    state.lock().unwrap().directory = dir;
    Ok(())
}

#[tauri::command]
pub fn get_problem(state: State<'_, Mutex<AppState>>) -> Problem {
    state.lock().unwrap().problem.clone()
}

#[tauri::command]
pub fn set_problem(problem: Problem, state: State<'_, Mutex<AppState>>) {
    state.lock().unwrap().problem = problem
}

#[tauri::command]
pub fn get_verdicts(state: State<'_, Mutex<AppState>>) -> Vec<Verdict> {
    state.lock().unwrap().verdicts.clone()
}

#[tauri::command]
pub fn set_verdicts(verdicts: Vec<Verdict>, state: State<'_, Mutex<AppState>>) {
    state.lock().unwrap().verdicts = verdicts
}

#[tauri::command]
pub fn save_state(
    handle: tauri::AppHandle,
    state: State<'_, Mutex<AppState>>,
) -> Result<(), String> {
    let mut file_path = handle.path().app_config_dir().map_to_string()?;
    file_path.push("cp_state.json");

    let state = state.lock().unwrap().deref().clone();

    let mut f = File::create(file_path).map_to_string()?;
    f.write_fmt(format_args!(
        "{}",
        serde_json::to_string(&state).map_to_string()?
    ))
    .map_to_string()?;

    Ok(())
}

#[tauri::command]
pub async fn create_file(app_state: State<'_, Mutex<AppState>>) -> Result<(), String> {
    let state = app_state.lock().unwrap().clone();
    let config = &state.config;

    let file_path = state
        .config
        .get_file_path(&state.problem, &state.directory)?;
    create_dir_all(&file_path.parent().unwrap()).map_to_string()?;

    if file_path.exists() && !config.editor.is_empty() {
        open::with(&file_path, config.editor.clone()).map_to_string()?;
        return Ok(());
    }

    let mut f = File::create_new(&file_path).map_to_string()?;

    f.write_fmt(format_args!(
        "{} Created by {} at {:#?}\n{} {}\n{}",
        state.get_language()?.comment,
        config.author,
        time::Instant::now(),
        state.get_language()?.comment,
        state.problem.url,
        config.get_template(&state.directory)
    ))
    .map_to_string()?;

    if !config.editor.is_empty() {
        open::with(&file_path, config.editor.clone()).map_to_string()?;
    }

    Ok(())
}

--- END FILE: src-tauri/src/state.rs ---


--- START FILE: src-tauri/src/submit.rs ---
use std::sync::Mutex;

use actix_web::{get, post, web, HttpResponse, Responder};
use serde::{Deserialize, Serialize};
use tauri_plugin_http::reqwest;

use crate::{utils::ResultTrait, AppState};

pub struct WebState {
    pub sol: Mutex<Option<Solution>>,
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Solution {
    empty: bool,
    problem_name: String,
    url: String,
    source_code: String,
    language_id: usize,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct EmptySolution {
    empty: bool,
}

#[get("/getSubmit")]
pub async fn get_submit(data: web::Data<WebState>) -> impl Responder {
    let sol = data.sol.lock().unwrap().take();

    if sol.is_some() {
        let solution = sol.unwrap();

        #[cfg(debug_assertions)]
        println!("submitting solution");

        return HttpResponse::Ok().json(solution);
    }

    #[cfg(debug_assertions)]
    println!("no solution returning empty");

    HttpResponse::Ok().json(EmptySolution { empty: true })
}

#[post("/submit")]
pub async fn post_submit(sol: web::Json<Solution>, data: web::Data<WebState>) -> impl Responder {
    let _ = data.sol.lock().unwrap().insert(sol.0);

    #[cfg(debug_assertions)]
    println!("inserted solution into data");

    HttpResponse::Ok()
}

#[tauri::command]
pub async fn submit_solution(app_state: tauri::State<'_, Mutex<AppState>>) -> Result<(), String> {
    let state = app_state.lock().unwrap().clone();
    let source_code = state
        .config
        .get_final_code(&state.problem, &state.directory)?;
    let client = reqwest::Client::builder().build().map_to_string()?;

    let problem_name = state
        .problem
        .url
        .split('/')
        .rev()
        .take(2)
        .collect::<Vec<&str>>()
        .into_iter()
        .rev()
        .collect::<Vec<&str>>()
        .join("");

    let solution = Solution {
        empty: false,
        language_id: state.get_language().map_to_string()?.cf_id,
        problem_name,
        source_code,
        url: state.problem.url,
    };

    let post_request = client
        .post("http://localhost:27121/submit")
        .json(&solution)
        .build()
        .map_to_string()?;

    client.execute(post_request).await.map_to_string()?;

    Ok(())
}

--- END FILE: src-tauri/src/submit.rs ---


--- START FILE: src-tauri/src/utils.rs ---
use std::{
    fmt::Display,
    path::{Path, PathBuf},
};

pub trait ResultTrait<T> {
    fn map_to_string(self) -> Result<T, String>;
    fn map_to_string_mess(self, mess: &str) -> Result<T, String>;
}

impl<T, E> ResultTrait<T> for Result<T, E>
where
    E: Display,
{
    fn map_to_string(self) -> Result<T, String> {
        self.map_err(|err| format!("{err}"))
    }

    fn map_to_string_mess(self, mess: &str) -> Result<T, String> {
        self.map_err(|err| format!("{mess} {err}"))
    }
}

pub fn resolve_path(dir: &Path, path: &str) -> PathBuf {
    // Handle both Unix and Windows style relative paths
    if path.starts_with("./") || path.starts_with(".\\") {
        dir.join(&path[2..]) // Remove "./" or ".\\" and join with dir
    } else {
        PathBuf::from(path) // Use command as-is if it's not relative
    }
}

pub fn extract_code_block(source: &str) -> String {
    let mut lines = source.lines();
    // Find the start marker
    while let Some(line) = lines.next() {
        if line.contains("@code") && line.contains("begin") {
            break;
        }
    }
    // Collect lines until the end marker
    let mut code_block = Vec::new();
    for line in lines {
        if line.contains("@code") && line.contains("end") {
            break;
        }
        code_block.push(line);
    }
    if code_block.is_empty() {
        source.to_string()
    } else {
        code_block.join("\n").trim().to_string()
    }
}

--- END FILE: src-tauri/src/utils.rs ---


--- START FILE: ./for_llm.sh ---
#!/usr/bin/env bash

# Script to generate a single text file from a Tauri project for LLM context.

# --- Configuration ---
DEFAULT_OUTPUT_FILENAME="tauri_project_context.txt"
OUTPUT_FILE="${1:-$DEFAULT_OUTPUT_FILENAME}"

# Maximum file size in KB to include (e.g., 1024KB = 1MB)
MAX_FILE_SIZE_KB=1024
MAX_FILE_SIZE_BYTES=$((MAX_FILE_SIZE_KB * 1024))

# --- Helper Functions ---

# Function to add file content to the output file
# Arguments:
#   $1: File path
add_file_content() {
  local filepath="$1"
  local filename
  filename=$(basename "$filepath")

  # Check if file exists and is readable
  if [ ! -f "$filepath" ] || [ ! -r "$filepath" ]; then
    echo "[SKIP] File not found or not readable: $filepath"
    return 1
  fi

  # Skip common lock files
  case "$filename" in
    "package-lock.json"|"yarn.lock"|"pnpm-lock.yaml"|"Cargo.lock")
      echo "[SKIP] Lock file (by name): $filepath"
      return 1
      ;;
  esac

  # Check file size
  local filesize
  filesize=$(stat -c%s "$filepath" 2>/dev/null || wc -c < "$filepath" | tr -d ' ')
  if [ "$filesize" -gt "$MAX_FILE_SIZE_BYTES" ]; then
    echo "[SKIP] File too large (${filesize}B > ${MAX_FILE_SIZE_BYTES}B): $filepath"
    return 1
  fi

  if [ "$filesize" -eq 0 ]; then
    echo "[SKIP] File is empty: $filepath"
  fi

  # Check if it's a binary file using 'file' command if available
  if command -v file &> /dev/null; then
    local mimetype
    mimetype=$(file -b --mime-type "$filepath")
    local is_text_mime=false
    case "$mimetype" in
      text/* | application/json | application/ld+json | \
      application/javascript | application/ecmascript | \
      application/xml | image/svg+xml | \
      application/x-sh | application/x-shellscript | \
      application/x-tcl | application/x-perl | application/x-python | application/x-ruby | \
      application/x-tex | application/rtf | \
      application/yaml | application/toml | \
      application/sql | inode/x-empty)
        is_text_mime=true
        ;;
      application/wasm)
        [[ "$filepath" == *.wat ]] && is_text_mime=true
        ;;
    esac
    if ! $is_text_mime; then
      echo "[SKIP] Likely binary or non-text (MIME: $mimetype): $filepath"
      return 1
    fi
  fi

  echo "--- START FILE: $filepath ---" >> "$OUTPUT_FILE"
  cat "$filepath" >> "$OUTPUT_FILE"
  echo "" >> "$OUTPUT_FILE"
  echo "--- END FILE: $filepath ---" >> "$OUTPUT_FILE"
  echo -e "\n" >> "$OUTPUT_FILE"
  echo "[ADDED] $filepath"
  return 0
}

# --- Main Script ---

# Ensure we're in a Tauri project root
if [ ! -f "src-tauri/tauri.conf.json" ]; then
  echo "[ERROR] 'src-tauri/tauri.conf.json' not found."
  echo "Please run this script from the root directory of your Tauri project."
  exit 1
fi

# Initialize output file with a warning header
cat << EOF > "$OUTPUT_FILE"
LLM CONTEXT FILE FOR TAURI PROJECT
GENERATED BY SCRIPT ON: $(date)

IMPORTANT: This file contains concatenated source code from the project.
Review it carefully for any sensitive information (API keys, passwords,
confidential algorithms, personal data, etc.) BEFORE sharing it with any
Large Language Model or third party.

EOF

echo "[INFO] Generating LLM context file: $OUTPUT_FILE"

# 1. Key configuration files
echo "[INFO] Processing key configuration files..."
KEY_CONFIG_FILES=(
  "README.md" "README.txt" "readme.md"
  "package.json"
  "vite.config.js" "vite.config.ts" "vite.config.mjs"
  "webpack.config.js" "webpack.config.ts"
  "svelte.config.js"
  "next.config.js" "next.config.mjs"
  "nuxt.config.js" "nuxt.config.ts"
  "angular.json"
  "vue.config.js"
  "tsconfig.json" "jsconfig.json"
  "postcss.config.js" "tailwind.config.js" "tailwind.config.ts"
  ".env.example" ".env.sample"
  "src-tauri/tauri.conf.json"
  "src-tauri/Cargo.toml"
  "src-tauri/build.rs"
)

for f in "${KEY_CONFIG_FILES[@]}"; do
  [ -f "$f" ] && add_file_content "$f"
done

# 2. Rust source files
echo "[INFO] Processing Rust backend source files (src-tauri/src)..."
find src-tauri/src -type f -name "*.rs" -print0 | while IFS= read -r -d $'\0' file; do
  add_file_content "$file"
done

# 3. Frontend source files
echo "[INFO] Processing frontend source files..."

FILE_PATTERNS_TO_INCLUDE=(
  "*.html" "*.htm"
  "*.css" "*.scss" "*.sass" "*.less" "*.pcss" "*.postcss"
  "*.js" "*.jsx" "*.mjs" "*.cjs"
  "*.ts" "*.tsx" "*.mts" "*.cts"
  "*.vue" "*.svelte"
  "*.md" "*.json" "*.xml" "*.yaml" "*.yml" "*.toml"
  "*.svg"
  "*.sh" "*.bash"
  "*.graphql" "*.gql"
  "*.wat"
  "*.glsl" "*.frag" "*.vert" "*.txt"
)

FRONTEND_DIRS_TO_SEARCH=(
  "." "src" "app"
  "components" "ui"
  "pages" "views" "routes"
  "layouts"
  "lib" "utils" "services" "store"
  "styles" "css" "scss"
  "assets" "public" "static"
  "src/app" "src/routes"
  "src/components" "src/ui"
  "src/pages" "src/views"
  "src/layouts"
  "src/lib" "src/utils" "src/services" "src/store"
  "src/styles" "src/assets"
)

EXCLUDE_PATH_PREFIXES=(
  "./node_modules/"
  "./.git/" "./dist/" "./build/" "./out/"
  "./target/" "./src-tauri/target/"
  "./.tauri/" "./.vscode/" "./.idea/" "./.fleet/"
  "./__pycache__/" "./.DS_Store"
  "./$OUTPUT_FILE"
)

PROCESSED_FILES_CANONICAL=()

for search_dir in "${FRONTEND_DIRS_TO_SEARCH[@]}"; do
  [ ! -d "$search_dir" ] && continue
  echo "[INFO] Searching in '$search_dir' directory..."

  find_args=("$search_dir")
  [ "$search_dir" == "." ] && find_args+=("-maxdepth" "1") || find_args+=("-maxdepth" "10")
  find_args+=("-type" "f" "(")

  first_pattern=true
  for pattern in "${FILE_PATTERNS_TO_INCLUDE[@]}"; do
    $first_pattern || find_args+=("-o")
    find_args+=("-iname" "$pattern")
    first_pattern=false
  done
  find_args+=(")" "-print0")

  find "${find_args[@]}" 2>/dev/null | while IFS= read -r -d $'\0' found_file; do
    normalized_found_file="${found_file#./}"

    is_excluded=false
    for exclude_prefix in "${EXCLUDE_PATH_PREFIXES[@]}"; do
      normalized_exclude_prefix="${exclude_prefix#./}"
      [[ "$normalized_found_file" == "$normalized_exclude_prefix"* ]] && is_excluded=true && break
    done
    $is_excluded && continue

    canonical_file_path=$(realpath "$found_file" 2>/dev/null)
    [ -z "$canonical_file_path" ] && canonical_file_path="$normalized_found_file"

    skip_duplicate=false
    for processed_path in "${PROCESSED_FILES_CANONICAL[@]}"; do
      [[ "$processed_path" == "$canonical_file_path" ]] && skip_duplicate=true && break
    done
    $skip_duplicate && continue

    if add_file_content "$found_file"; then
      PROCESSED_FILES_CANONICAL+=("$canonical_file_path")
    fi
  done
done

# --- Finalization ---
echo ""
TOTAL_LINES=$(wc -l < "$OUTPUT_FILE" | tr -d ' ')
TOTAL_SIZE=$(du -h "$OUTPUT_FILE" | cut -f1)

echo "[SUCCESS] LLM context file '$OUTPUT_FILE' generated."
echo "  Total lines: $TOTAL_LINES"
echo "  Total size: $TOTAL_SIZE"
echo ""
echo "[IMPORTANT REMINDER]"
echo "Please carefully review '$OUTPUT_FILE' and REMOVE any sensitive information"
echo "(API keys, passwords, personal data, proprietary code not meant for sharing, etc.)"
echo "BEFORE using

--- END FILE: ./for_llm.sh ---


--- START FILE: ./index.html ---
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tauri + React + Typescript</title>
  </head>

  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

--- END FILE: ./index.html ---


--- START FILE: ./package.json ---
{
  "name": "cp-assist",
  "private": true,
  "version": "0.2.1",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "tauri": "tauri"
  },
  "dependencies": {
    "@mantine/core": "^7.12.0",
    "@mantine/hooks": "^7.12.0",
    "@mantine/modals": "^7.12.0",
    "@mantine/notifications": "^7.12.0",
    "@tabler/icons-react": "^3.12.0",
    "@tauri-apps/api": "2.0.0-rc.2",
    "@tauri-apps/plugin-dialog": "2.0.0-rc.0",
    "@tauri-apps/plugin-http": "2.0.0-rc.1",
    "@tauri-apps/plugin-shell": "2.0.0-rc.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1"
  },
  "devDependencies": {
    "@tauri-apps/cli": "2.0.0-rc.5",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.1",
    "autoprefixer": "^10.4.20",
    "postcss": "^8.4.41",
    "tailwindcss": "^3.4.9",
    "typescript": "^5.5.4",
    "vite": "^5.4.0"
  }
}
--- END FILE: ./package.json ---


--- START FILE: ./postcss.config.js ---
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

--- END FILE: ./postcss.config.js ---


--- START FILE: ./README.md ---
# CP-Assist

CP-Assist is a comprehensive desktop application designed to streamline your competitive programming workflow, integrating with popular tools to automate test case management, code execution, and solution submission.

## Table of Contents
- [App Preview](#app-preview)
- [Features](#features)
- [Installation](#installation)
- [Usage](#usage)
- [Configuration](#configuration)

## App Preview


![alt text](https://github.com/veryshyjelly/cp-assist/blob/main/cp-assist-shot.png?raw=true)

https://github.com/user-attachments/assets/516eacd3-817e-4e87-bcbf-0817f914553f

- **Test Case Handling**: Automated collection and management of test cases
- **Code Execution & Judging**: Local testing environment with verdict generation
- **Language Support**: Multi-language compatibility with customizable configurations
- **Submission System**: Direct integration with online judges for solution submission

## Installation

### Prerequisites
- [Competitive Companion](https://github.com/jmerle/competitive-companion) browser extension
- [CP-Submit](https://github.com/tsycho/cp-submit) for submission integration

### Linux
- **AppImage**: [Download](https://github.com/veryshyjelly/cp-assist/releases/download/v0.2.1/cp-assist_0.2.1_amd64.AppImage)
- **Arch Linux**: [.tar file](https://github.com/veryshyjelly/cp-assist/releases/download/v0.2.1/cp-assist-0.2.1-1-x86_64.pkg.tar.zst)
- **Debian/Ubuntu**: [.deb file](https://github.com/veryshyjelly/cp-assist/releases/download/v0.2.1/cp-assist_0.2.1_amd64.deb)
- **Red Hat/Fedora**: [.rpm file](https://github.com/veryshyjelly/cp-assist/releases/download/v0.2.1/cp-assist-0.2.1-1.x86_64.rpm)

### Windows
- **MSI Installer**: [Download](https://github.com/veryshyjelly/cp-assist/releases/download/v0.2.1/cp-assist_0.2.1_x64_en-US.msi)
- **Setup EXE**: [Download](https://github.com/veryshyjelly/cp-assist/releases/download/v0.2.1/cp-assist_0.2.1_x64-setup.exe)

## Usage

1. **Getting Problems**: Navigate to a problem on a supported online judge and use Competitive Companion to send it to CP-Assist
2. **Solving & Testing**: Write your solution and test against provided test cases
3. **Submitting**: Submit your solution directly to the online judge

## Configuration

CP-Assist can be configured through the Settings menu to customize languages, editor preferences, and appearance.


--- END FILE: ./README.md ---


--- START FILE: ./tailwind.config.js ---
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
--- END FILE: ./tailwind.config.js ---


--- START FILE: ./tsconfig.json ---
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}

--- END FILE: ./tsconfig.json ---


--- START FILE: ./tsconfig.node.json ---
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}

--- END FILE: ./tsconfig.node.json ---


--- START FILE: ./vite.config.ts ---
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

// @ts-expect-error process is a nodejs global
const host = process.env.TAURI_DEV_HOST;

// https://vitejs.dev/config/
export default defineConfig(async () => ({
  plugins: [react()],

  // Vite options tailored for Tauri development and only applied in `tauri dev` or `tauri build`
  //
  // 1. prevent vite from obscuring rust errors
  clearScreen: false,
  // 2. tauri expects a fixed port, fail if that port is not available
  server: {
    port: 1420,
    strictPort: true,
    host: host || false,
    hmr: host
      ? {
          protocol: "ws",
          host,
          port: 1421,
        }
      : undefined,
    watch: {
      // 3. tell vite to ignore watching `src-tauri`
      ignored: ["**/src-tauri/**"],
    },
  },
}));

--- END FILE: ./vite.config.ts ---


--- START FILE: src/App.css ---
@tailwind base;
@tailwind components;
@tailwind utilities;

textarea {
  color: white !important;
  height: 100% !important;
  font-size: 20px !important;
  font-family: monospace !important;
}

input {
  height: 100%;
  color: white !important;
  font-size: 18px !important;
  font-family: monospace !important;
}

body {
  user-select: none;
}

--- END FILE: src/App.css ---


--- START FILE: src/App.tsx ---
import "./App.css";
import { Box } from "@mantine/core";
import TitleBar from "./Titlebar.tsx";
import LandingPage from "./LandingPage.tsx";
import { useEffect, useState } from "react";
import Home from "./Home.tsx";
import { Problem, Verdict } from "./Languages.ts";
import { listen } from "@tauri-apps/api/event";
import {
  get_directory,
  get_problem,
  get_verdicts,
  set_problem,
  set_verdicts,
} from "./commands.tsx";

function App() {
  const [directory, setDirectory] = useState("");
  const [problem, setProblem] = useState<Problem | null>(null);
  const [verdicts, setVerdicts] = useState<Verdict[]>([]);

  useEffect(() => {
    get_directory().then((dir) => setDirectory(dir));
    get_problem().then((pro) => setProblem(pro));
    get_verdicts().then((ver) => setVerdicts(ver || []));
    listen<Problem>("set-problem", (event) =>
      set_problem(event.payload).then(() => setProblem(event.payload)),
    );
    listen<Verdict[]>("set-verdicts", (event) =>
      set_verdicts(event.payload).then(() => setVerdicts(event.payload)),
    );
  }, []);

  return (
    <Box
      className="bg-[#1e1f22] border border-[#3c3f41]"
      style={{ height: "100%", width: "100%", position: "fixed" }}
    >
      <TitleBar setDirectory={setDirectory} directory={directory} />
      {directory === "" && <LandingPage setDirectory={setDirectory} />}
      {directory !== "" && <Home problem={problem} verdicts={verdicts} />}
    </Box>
  );
}

export default App;

--- END FILE: src/App.tsx ---


--- START FILE: src/commands.tsx ---
import { invoke } from "@tauri-apps/api/core";
import { notifications } from "@mantine/notifications";
import { IconCheck, IconX } from "@tabler/icons-react";
import { Language, Problem, Verdict } from "./Languages.ts";

async function invokeWithNotify<T>(
  cmd: string,
  args: Record<string, any> = {},
  successMessage?: string,
  errorMessage?: string,
): Promise<T | null> {
  try {
    const result = await invoke<T>(cmd, args);
    if (successMessage) {
      notifications.show({
        id: `success_${cmd}`,
        message: successMessage,
        icon: <IconCheck size="1.1rem" />,
        color: "teal",
      });
    }
    return result;
  } catch (e) {
    console.error(e);
    notifications.show({
      id: `error_${cmd}`,
      message: errorMessage ? `${errorMessage}: ${e}` : (e as string),
      icon: <IconX size="1.1rem" />,
      color: "red",
    });
    return null;
  }
}

export const set_directory = async (directory: string) =>
  (await invokeWithNotify<boolean>(
    "set_directory",
    { directory },
    undefined,
    "The specified directory was not found",
  )) ?? false;

export const get_directory = async () =>
  (await invokeWithNotify<string>(
    "get_directory",
    {},
    undefined,
    "Cannot get the directory",
  )) ?? "";

export const set_language = async (language_id: number) =>
  (await invokeWithNotify<boolean>(
    "set_language",
    { languageId: language_id },
    "Language set successfully",
    "Could not set language",
  )) ?? false;

export const get_language = async () =>
  (await invokeWithNotify<number>(
    "get_language",
    {},
    undefined,
    "Could not get language",
  )) ?? 0;

export const get_languages = async () =>
  (await invokeWithNotify<Language[]>(
    "get_languages",
    {},
    undefined,
    "Could not get languages",
  )) ?? [];

export const set_problem = async (problem: Problem) =>
  (await invokeWithNotify<boolean>(
    "set_problem",
    { problem },
    undefined,
    "Could not set problem",
  )) ?? false;

export const get_problem = async () =>
  await invokeWithNotify<Problem>(
    "get_problem",
    {},
    undefined,
    "Could not get problem",
  );

export const set_verdicts = async (verdicts: Verdict[]) =>
  (await invokeWithNotify<boolean>(
    "set_verdicts",
    { verdicts },
    undefined,
    "Could not set verdicts",
  )) ?? false;

export const get_verdicts = async () =>
  await invokeWithNotify<Verdict[]>(
    "get_verdicts",
    {},
    undefined,
    "Could not get verdicts",
  );

export const read_config = async () =>
  (await invokeWithNotify<null>(
    "read_config",
    {},
    "Config file succesfully read",
  )) ?? false;

export const create_file = async () =>
  (await invokeWithNotify<boolean>(
    "create_file",
    {},
    "File created",
    "Could not create file",
  )) ?? false;

export const save_state = async () =>
  (await invokeWithNotify<boolean>(
    "save_state",
    {},
    undefined,
    "Could not save state",
  )) ?? false;

export const submit = async () =>
  await invokeWithNotify<null>(
    "submit_solution",
    {},
    "Submitting on codeforces...",
    "Could not submit",
  );

export const run = async () =>
  await invokeWithNotify<null>("test", {}, undefined, "Could not run test");

--- END FILE: src/commands.tsx ---


--- START FILE: src/Home.tsx ---
import {
  Box,
  Center,
  Flex,
  Group,
  Select,
  Stack,
  Text,
  Textarea,
} from "@mantine/core";
import { useEffect, useState } from "react";
import { LogicalSize } from "@tauri-apps/api/window";
import { getCurrentWebviewWindow } from "@tauri-apps/api/webviewWindow";
import { Problem, Verdict } from "./Languages.ts";
import { IconPlus } from "@tabler/icons-react";
import { emit } from "@tauri-apps/api/event";
import { read_config } from "./commands.tsx";

const appWindow = getCurrentWebviewWindow();

const MyTextarea = ({
  title,
  value,
  mx,
  onChange,
}: {
  title: string;
  value: string;
  mx: number | string | undefined;
  onChange: (v: string) => void;
}) => {
  return (
    <Box
      h={"90%"}
      w={"31%"}
      fw={500}
      bg={"#282828"}
      className={`text-3xl border border-gray-600 relative text-center select-none font-mono
                            rounded-md tracking-widest pt-1`}
      mx={mx}
    >
      {title}
      <Textarea
        className={`h-[91%] w-full px-2 top-10 bg-[#3e3e3e]/50 rounded-md absolute`}
        variant="unstyled"
        maxRows={15}
        autosize
        onChange={(v) => onChange(v.currentTarget.value)}
        value={value}
      />
    </Box>
  );
};

const Home = ({
  problem,
  verdicts,
}: {
  problem: Problem | null;
  verdicts: Verdict[];
}) => {
  let [caseIndex, setCaseIndex] = useState(0);
  const [input, setInput] = useState("");
  const [output, setOutput] = useState("");
  const [answer, setAnswer] = useState("");
  const [editable, setEditable] = useState(false);
  const otherVerdict =
    verdicts.filter((v) => v.status_id !== 3)[0] || verdicts[caseIndex];
  const cases = Array.from(Array(verdicts.length).keys())
    .map((x) => ({
      label:
        `Case ${x + 1} ` +
        (verdicts[x]?.status_id === 3
          ? "✔️"
          : verdicts[x]?.status_id < 3
            ? ""
            : "❌"),
      value: `${x + 1}`,
    }))
    .concat({ label: "Add Case", value: "-1" });

  const onCaseChange = (v: string | null): void => {
    let index = parseInt(v ?? "1") - 1;
    if (index == -2) {
      setEditable(true);
    } else {
      setEditable(false);
    }
    setCaseIndex(index);
    setInput(verdicts[index]?.input ?? "");
    setOutput(verdicts[index]?.output ?? "");
    setAnswer(verdicts[index]?.answer ?? "");
  };

  const onEdit = (setAny: (v: string) => void) => {
    if (!editable) return (_: string) => {};
    return setAny;
  };

  const onAddTestCase = () => {
    if (!editable) return;
    verdicts.push({
      input: input,
      answer: answer,
      output: "",
      memory: 0,
      status: "NA",
      status_id: 0,
      time: 0,
    });
    emit("set-verdicts", verdicts);
  };

  useEffect(() => {
    read_config();
    setInput(verdicts[caseIndex]?.input ?? "");
    setOutput(verdicts[caseIndex]?.output ?? "");
    setAnswer(verdicts[caseIndex]?.answer ?? "");
    appWindow.setSize(new LogicalSize(1000, 650)).then(null);
  }, [verdicts]);

  return problem?.title ? (
    <Stack h={"95%"}>
      <Flex className={"mt-5 justify-center content-center"}>
        <Text
          w={500}
          fz={32}
          fw={600}
          c={"white"}
          className={"select-none tracking-widest text-center"}
        >
          {problem?.title}
        </Text>
      </Flex>

      <Stack
        c={"white"}
        w={"95%"}
        mx={"auto"}
        px={40}
        className={"text-2xl h-full rounded-md"}
      >
        {/*Heading Area*/}
        <Group my={0}>
          <Select
            variant="unstyled"
            onChange={onCaseChange}
            data={cases}
            w={150}
            pl={10}
            py={4}
            bg={"#2b2d30"}
            className={"rounded-md"}
            checkIconPosition={"right"}
            defaultValue={"1"}
            allowDeselect={false}
          />
          {editable && (
            <IconPlus
              onClick={onAddTestCase}
              className="ml-3 cursor-pointer border-white/15 border rounded-full"
              title="Save Test Case"
            />
          )}
          {verdicts[caseIndex]?.time && (
            <Group mx={10}>
              <Text ff={"monospace"} c={"#fcfcfc"} fz={20}>
                {verdicts[caseIndex]?.time * 1000 + " ms"}
              </Text>
              <Text ff={"monospace"} c={"#fcfcfc"} fz={20}>
                {Math.floor(verdicts[caseIndex]?.memory / 1024) + " Mb"}
              </Text>
            </Group>
          )}

          {!editable && (
            <Text
              fz={26}
              fw={600}
              ml={"md"}
              my={"auto"}
              ff={"monospace"}
              className={"tracking-wider"}
              style={{
                color:
                  otherVerdict?.status_id === 3
                    ? "#2cad40"
                    : otherVerdict?.status_id < 3
                      ? "gray"
                      : "red",
              }}
            >
              {otherVerdict?.status}
            </Text>
          )}
        </Group>

        <Group h={"90%"} w={"100%"}>
          <MyTextarea
            title={"Input"}
            value={input}
            mx={0}
            onChange={(v) => onEdit(setInput)(v)}
          />
          <MyTextarea
            title={"Answer"}
            value={answer}
            mx={"auto"}
            onChange={(v) => onEdit(setAnswer)(v)}
          />
          <MyTextarea
            title={"Output"}
            value={output}
            mx={0}
            onChange={() => {}}
          />
        </Group>
      </Stack>
    </Stack>
  ) : (
    <Center h={"90%"}>
      <Text c={"#acacac"} fz={32} className={"tracking-wider"}>
        Select problem from competitive companion
      </Text>
    </Center>
  );
};

export default Home;

--- END FILE: src/Home.tsx ---


--- START FILE: src/LandingPage.tsx ---
import {Box, Flex, Image, Space, Stack, Text} from "@mantine/core";
import {open} from '@tauri-apps/plugin-dialog';
import React, {useEffect} from "react";
import {getCurrentWindow, LogicalSize} from "@tauri-apps/api/window"
import {set_directory} from "./commands.tsx";
const appWindow = getCurrentWindow()

const LandingPage = ({setDirectory}: { setDirectory: React.Dispatch<React.SetStateAction<string>> }) => {
    useEffect(() => {
        appWindow.setSize(new LogicalSize(600, 450)).then(null);
    }, [])

    const chooseFolder = async () => {
        const selected = await open({
            directory: true,
            multiple: false,
            defaultPath: "C:/"
        });
        console.log(selected);
        if (!(Array.isArray(selected) || selected === null)) {
            let dir = selected.replace(/\\/g, "/")
            if (await set_directory(dir)) {
                setDirectory(dir);
            }
        }
    }

    return (
        <Flex direction={"column"} align={"center"} style={{userSelect: "none"}}>
            <Text c={"#dee0e2"} fw={500} mt={50} fz={40}>
                Welcome to CP-Assist
            </Text>
            <Space h={"md"}/>
            <Text c={"#6f737a"} fz={"md"}>
                Create a new project to start from scratch or open existing folder.
            </Text>
            <Space h={"lg"}/>
            <Flex>
                <Stack m={40}>
                    <Box bg={"#2b2d30"} p={15} style={{borderRadius: 7, cursor: 'pointer'}} onClick={chooseFolder}>
                        <Image src={"/add.svg"} w={35} m={"auto"}/>
                    </Box>
                    <Text fz={"xs"} c={"#d5dee1"}>New Project</Text>
                </Stack>
                <Stack m={40}>
                    <Box bg={"#2b2d30"} p={15} style={{borderRadius: 7, cursor: 'pointer'}} onClick={chooseFolder}>
                        <Image src={"/folder.svg"} w={35} m={"auto"}/>
                    </Box>
                    <Text fz={"xs"} c={"#d5dee1"}>Open Existing</Text>
                </Stack>
            </Flex>
        </Flex>
    );
}

export default LandingPage;
--- END FILE: src/LandingPage.tsx ---


--- START FILE: src/Languages.ts ---
export type Language = {
    id: number,
    name: string
}

export type Verdict = {
    input: string,
    output: string,
    answer: string,
    status: string,
    status_id: number,
    time: number,
    memory: number
}

export type Problem = {
    url: string,
    memory_limit: number,
    time_limit: number,
    title: string,
}
--- END FILE: src/Languages.ts ---


--- START FILE: src/main.tsx ---
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import '@mantine/core/styles.css'
import {MantineProvider} from "@mantine/core";
import {Notifications} from "@mantine/notifications";

ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
    <React.StrictMode>
        <MantineProvider defaultColorScheme={"dark"}>
            <Notifications limit={5} pos={"absolute"} className={"bottom-5 left-3"} w={"auto"}/>
            <App/>
        </MantineProvider>
    </React.StrictMode>,
);

--- END FILE: src/main.tsx ---


--- START FILE: src/Titlebar.tsx ---
import { Center, Flex, Group, Image, Select, Text } from "@mantine/core";
import { getCurrentWindow } from "@tauri-apps/api/window";
import { useEffect, useState } from "react";
import { invoke } from "@tauri-apps/api/core";
import {
  create_file,
  get_language,
  get_languages,
  run,
  set_directory,
  set_language,
  submit,
} from "./commands.tsx";
import { IconCheck } from "@tabler/icons-react";

const appWindow = getCurrentWindow();

const TitleBar = ({
  directory,
  setDirectory,
}: {
  directory: string;
  setDirectory: (arg0: string) => void;
}) => {
  const [isFocused, setIsFocused] = useState(true);
  const [loading, setLoading] = useState(false);
  const [language, setLanguage] = useState("0");
  const [languages, setLanguages] = useState<
    { value: string; label: string }[]
  >([]);
  const trimmedLanguages = languages.map((v) => {
    return { label: v.label.split("(")[0], value: v.value };
  });

  const languageFromId = (id: string) =>
    languages.filter((v) => v.value === id)[0].label;

  const onChangeLanguage = async (value: string | null) => {
    if (value === null) return;
    let success = await set_language(parseInt(value));
    if (success) setLanguage(value);
  };

  const onRun = async () => {
    setLoading(true);
    await run();
    setLoading(false);
  };

  useEffect(() => {
    getCurrentWindow().onCloseRequested(() => {
      invoke("save_state")
        .then(null)
        .catch((e) => console.error(e));
    });
    get_language().then((v) => setLanguage(v.toString()));
    get_languages().then((v) =>
      setLanguages(
        v.map((x) => {
          return { value: x.id.toString(), label: x.name };
        }),
      ),
    );

    window.addEventListener("focus", () => setIsFocused(true));
    window.addEventListener("blur", () => setIsFocused(false));
  }, []);

  return (
    <Flex
      h={40}
      data-tauri-drag-region
      style={{ backgroundColor: isFocused ? "#2b2d30" : "#3c3f41" }}
    >
      {directory !== "" && (
        <>
          <Center
            h={33}
            w={33}
            mx={3}
            my={"auto"}
            className="rounded-full hover:bg-[#484b4d] z-10"
            onClick={() => {
              set_directory("").then(() => setDirectory(""));
            }}
          >
            <Image src="back.svg" h={25} />
          </Center>

          <Flex w={"100%"} h={40} pos={"absolute"} data-tauri-drag-region>
            <Flex my={"auto"} mx={"auto"}>
              {loading && (
                <Center
                  h={35}
                  w={180}
                  my={"auto"}
                  mx={5}
                  className="rounded-md bg-[#484b4d] cursor-pointer"
                >
                  <Image src="pending.gif" h={60} />
                  <Text mx={10} c={"white"}>
                    Running
                  </Text>
                </Center>
              )}
              {!loading && (
                <>
                  <Center
                    h={35}
                    w={80}
                    my={"auto"}
                    mx={5}
                    className="bg-black/15 rounded-md hover:bg-[#484b4d] cursor-pointer"
                    onClick={onRun}
                  >
                    <Image src="play.svg" h={25} ml={10} />
                    <Text mx={10} c={"white"}>
                      Run
                    </Text>
                  </Center>
                  <Center
                    h={35}
                    my={"auto"}
                    w={115}
                    className="bg-black/15 rounded-md hover:bg-[#484b4d] cursor-pointer"
                    onClick={() => submit()}
                  >
                    <Image src="submit.svg" h={25} ml={10} />
                    <Text mx={10} c={"#28c244"}>
                      Submit
                    </Text>
                  </Center>
                </>
              )}
            </Flex>
          </Flex>
        </>
      )}

      <Flex ml={"auto"} />

      {directory !== "" && (
        <>
          <Center
            h={34}
            w={34}
            my={"auto"}
            mx={2}
            title={"Create File"}
            className="rounded-md hover:bg-[#484b4d] cursor-pointer z-10"
            onClick={() => create_file()}
          >
            <Image src="create_file.svg" h={22} />
          </Center>

          <Select
            h={35}
            my={"auto"}
            w={160}
            variant="light"
            c={"white"}
            defaultValue={"0"}
            data={trimmedLanguages}
            value={language}
            className={"bg-black/15 rounded-md z-10"}
            onChange={onChangeLanguage}
            allowDeselect={false}
            comboboxProps={{ width: 250 }}
            renderOption={({ option, checked }) => (
              <Group>
                <Text fz={18} fw={"500"} className={"tracking-wider"}>
                  {languageFromId(option.value)}
                </Text>{" "}
                {checked && (
                  <IconCheck style={{ marginInlineStart: "auto" }} />
                )}{" "}
              </Group>
            )}
          />
        </>
      )}

      <Flex ml={10} style={{ zIndex: 3 }}>
        <Center
          h={40}
          w={36}
          className="hover:bg-[#484b4d]"
          onClick={() => appWindow.minimize()}
        >
          <Image src="minimize.svg" />
        </Center>
        <Center h={40} w={36}>
          <Image src="maximize.svg" />
        </Center>
        <Center
          h={40}
          w={36}
          className="hover:bg-[#e81123]"
          onClick={() => appWindow.close()}
        >
          <Image src="close.svg" />
        </Center>
      </Flex>
    </Flex>
  );
};

export default TitleBar;

--- END FILE: src/Titlebar.tsx ---


--- START FILE: src/vite-env.d.ts ---
/// <reference types="vite/client" />

--- END FILE: src/vite-env.d.ts ---


--- START FILE: public/add.svg ---
<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 -960 960 960" width="24"><path fill="#3574f0" d="M440-440H200v-80h240v-240h80v240h240v80H520v240h-80v-240Z"/></svg>
--- END FILE: public/add.svg ---


--- START FILE: public/back.svg ---
<?xml version="1.0" ?><svg height="48" viewBox="0 0 48 48" width="48" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h48v48h-48z" fill="none"/><path fill="white" d="M40 22h-24.34l11.17-11.17-2.83-2.83-16 16 16 16 2.83-2.83-11.17-11.17h24.34v-4z"/></svg>
--- END FILE: public/back.svg ---


--- START FILE: public/close.svg ---
<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path fill="white" d="M19 6.41L17.59 5L12 10.59L6.41 5L5 6.41L10.59 12L5 17.59L6.41 19L12 13.41L17.59 19L19 17.59L13.41 12L19 6.41Z"/></svg>
--- END FILE: public/close.svg ---


--- START FILE: public/create_file.svg ---
<?xml version="1.0" ?><svg class="bi bi-file-earmark-plus" fill="#acacac" height="16" viewBox="0 0 16 16" width="16" xmlns="http://www.w3.org/2000/svg"><path d="M8 6.5a.5.5 0 0 1 .5.5v1.5H10a.5.5 0 0 1 0 1H8.5V11a.5.5 0 0 1-1 0V9.5H6a.5.5 0 0 1 0-1h1.5V7a.5.5 0 0 1 .5-.5z"/><path d="M14 4.5V14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h5.5L14 4.5zm-3 0A1.5 1.5 0 0 1 9.5 3V1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V4.5h-2z"/></svg>
--- END FILE: public/create_file.svg ---


--- START FILE: public/folder.svg ---
<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 -960 960 960" width="24"><path fill="#3574f0" d="M160-160q-33 0-56.5-23.5T80-240v-480q0-33 23.5-56.5T160-800h240l80 80h320q33 0 56.5 23.5T880-640v400q0 33-23.5 56.5T800-160H160Zm0-80h640v-400H447l-80-80H160v480Zm0 0v-480 480Z"/></svg>
--- END FILE: public/folder.svg ---


--- START FILE: public/maximize.svg ---
<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path fill="#acacac" d="M4 4h16v16H4V4m2 4v10h12V8H6Z"/></svg>
--- END FILE: public/maximize.svg ---


--- START FILE: public/minimize.svg ---
<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path fill="white" d="M20 14H4v-4h16"/></svg>
--- END FILE: public/minimize.svg ---


--- START FILE: public/next.svg ---
<svg aria-hidden="true" focusable="false" data-prefix="far" data-icon="chevron-right"
     class="svg-inline--fa fa-chevron-right absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2" role="img"
     xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512">
    <path fill="#dbdbdb"
          d="M305 239c9.4 9.4 9.4 24.6 0 33.9L113 465c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l175-175L79 81c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0L305 239z"></path>
</svg>
--- END FILE: public/next.svg ---


--- START FILE: public/play.svg ---
<svg fill="#acacac" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="play" class="svg-inline--fa fa-play absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512">
    <path fill="#acacac" d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/>
</svg>

--- END FILE: public/play.svg ---


--- START FILE: public/prev.svg ---
<svg aria-hidden="true" focusable="false" data-prefix="far" data-icon="chevron-left"
     class="svg-inline--fa fa-chevron-left absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2" role="img"
     xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512">
    <path fill="#dbdbdb"
          d="M15 239c-9.4 9.4-9.4 24.6 0 33.9L207 465c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9L65.9 256 241 81c9.4-9.4 9.4-24.6 0-33.9s-24.6-9.4-33.9 0L15 239z"></path>
</svg>
--- END FILE: public/prev.svg ---


--- START FILE: public/refresh.svg ---
<svg enable-background="new 0 0 70 70" height="70px" id="Icons" version="1.1" viewBox="0 0 70 70" width="70px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg">
    <path fill="white" d="M51.211,30.05V18.789L47.01,22.99C43.937,19.91,39.695,18,35,18c-9.389,0-17,7.611-17,17s7.611,17,17,17  c6.319,0,11.82-3.455,14.75-8.571l-3.475-1.986C44.032,45.354,39.823,48,35,48c-7.168,0-13-5.832-13-13c0-7.168,5.832-13,13-13  c3.585,0,6.828,1.464,9.18,3.82l-4.23,4.23H51.211z"/></svg>
--- END FILE: public/refresh.svg ---


--- START FILE: public/settings.svg ---
<?xml version="1.0" ?><svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><title/><g data-name="1" id="_1"><path fill="white" d="M293.9,450H233.53a15,15,0,0,1-14.92-13.42l-4.47-42.09a152.77,152.77,0,0,1-18.25-7.56L163,413.53a15,15,0,0,1-20-1.06l-42.69-42.69a15,15,0,0,1-1.06-20l26.61-32.93a152.15,152.15,0,0,1-7.57-18.25L76.13,294.1a15,15,0,0,1-13.42-14.91V218.81A15,15,0,0,1,76.13,203.9l42.09-4.47a152.15,152.15,0,0,1,7.57-18.25L99.18,148.25a15,15,0,0,1,1.06-20l42.69-42.69a15,15,0,0,1,20-1.06l32.93,26.6a152.77,152.77,0,0,1,18.25-7.56l4.47-42.09A15,15,0,0,1,233.53,48H293.9a15,15,0,0,1,14.92,13.42l4.46,42.09a152.91,152.91,0,0,1,18.26,7.56l32.92-26.6a15,15,0,0,1,20,1.06l42.69,42.69a15,15,0,0,1,1.06,20l-26.61,32.93a153.8,153.8,0,0,1,7.57,18.25l42.09,4.47a15,15,0,0,1,13.41,14.91v60.38A15,15,0,0,1,451.3,294.1l-42.09,4.47a153.8,153.8,0,0,1-7.57,18.25l26.61,32.93a15,15,0,0,1-1.06,20L384.5,412.47a15,15,0,0,1-20,1.06l-32.92-26.6a152.91,152.91,0,0,1-18.26,7.56l-4.46,42.09A15,15,0,0,1,293.9,450ZM247,420h33.39l4.09-38.56a15,15,0,0,1,11.06-12.91A123,123,0,0,0,325.7,356a15,15,0,0,1,17,1.31l30.16,24.37,23.61-23.61L372.06,328a15,15,0,0,1-1.31-17,122.63,122.63,0,0,0,12.49-30.14,15,15,0,0,1,12.92-11.06l38.55-4.1V232.31l-38.55-4.1a15,15,0,0,1-12.92-11.06A122.63,122.63,0,0,0,370.75,187a15,15,0,0,1,1.31-17l24.37-30.16-23.61-23.61-30.16,24.37a15,15,0,0,1-17,1.31,123,123,0,0,0-30.14-12.49,15,15,0,0,1-11.06-12.91L280.41,78H247l-4.09,38.56a15,15,0,0,1-11.07,12.91A122.79,122.79,0,0,0,201.73,142a15,15,0,0,1-17-1.31L154.6,116.28,131,139.89l24.38,30.16a15,15,0,0,1,1.3,17,123.41,123.41,0,0,0-12.49,30.14,15,15,0,0,1-12.91,11.06l-38.56,4.1v33.38l38.56,4.1a15,15,0,0,1,12.91,11.06A123.41,123.41,0,0,0,156.67,311a15,15,0,0,1-1.3,17L131,358.11l23.61,23.61,30.17-24.37a15,15,0,0,1,17-1.31,122.79,122.79,0,0,0,30.13,12.49,15,15,0,0,1,11.07,12.91ZM449.71,279.19h0Z"/><path fill="white" d="M263.71,340.36A91.36,91.36,0,1,1,355.08,249,91.46,91.46,0,0,1,263.71,340.36Zm0-152.72A61.36,61.36,0,1,0,325.08,249,61.43,61.43,0,0,0,263.71,187.64Z"/></g></svg>
--- END FILE: public/settings.svg ---


--- START FILE: public/submit.svg ---
<svg aria-hidden="true" focusable="false" data-prefix="far" data-icon="cloud-arrow-up" class="svg-inline--fa fa-cloud-arrow-up absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512">
    <path fill="#28c244" d="M354.9 121.7c13.8 16 36.5 21.1 55.9 12.5c8.9-3.9 18.7-6.2 29.2-6.2c39.8 0 72 32.2 72 72c0 4-.3 7.9-.9 11.7c-3.5 21.6 8.1 42.9 28.1 51.7C570.4 276.9 592 308 592 344c0 46.8-36.6 85.2-82.8 87.8c-.6 0-1.3 .1-1.9 .2H504 144c-53 0-96-43-96-96c0-41.7 26.6-77.3 64-90.5c19.2-6.8 32-24.9 32-45.3l0-.2v0 0c0-66.3 53.7-120 120-120c36.3 0 68.8 16.1 90.9 41.7zM512 480v-.2c71.4-4.1 128-63.3 128-135.8c0-55.7-33.5-103.7-81.5-124.7c1-6.3 1.5-12.8 1.5-19.3c0-66.3-53.7-120-120-120c-17.4 0-33.8 3.7-48.7 10.3C360.4 54.6 314.9 32 264 32C171.2 32 96 107.2 96 200l0 .2C40.1 220 0 273.3 0 336c0 79.5 64.5 144 144 144H464h40 8zM223 255c-9.4 9.4-9.4 24.6 0 33.9s24.6 9.4 33.9 0l39-39V384c0 13.3 10.7 24 24 24s24-10.7 24-24V249.9l39 39c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-80-80c-9.4-9.4-24.6-9.4-33.9 0l-80 80z"/></svg>

--- END FILE: public/submit.svg ---


--- START FILE: public/vite.svg ---
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
--- END FILE: public/vite.svg ---
