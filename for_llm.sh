#!/usr/bin/env bash

# Script to generate a single text file from a Tauri project for LLM context.

# --- Configuration ---
DEFAULT_OUTPUT_FILENAME="tauri_project_context.txt"
OUTPUT_FILE="${1:-$DEFAULT_OUTPUT_FILENAME}"

# Maximum file size in KB to include (e.g., 1024KB = 1MB)
MAX_FILE_SIZE_KB=1024
MAX_FILE_SIZE_BYTES=$((MAX_FILE_SIZE_KB * 1024))

# --- Helper Functions ---

# Function to add file content to the output file
# Arguments:
#   $1: File path
add_file_content() {
  local filepath="$1"
  local filename
  filename=$(basename "$filepath")

  # Check if file exists and is readable
  if [ ! -f "$filepath" ] || [ ! -r "$filepath" ]; then
    echo "[SKIP] File not found or not readable: $filepath"
    return 1
  fi

  # Skip common lock files
  case "$filename" in
    "package-lock.json"|"yarn.lock"|"pnpm-lock.yaml"|"Cargo.lock")
      echo "[SKIP] Lock file (by name): $filepath"
      return 1
      ;;
  esac

  # Check file size
  local filesize
  filesize=$(stat -c%s "$filepath" 2>/dev/null || wc -c < "$filepath" | tr -d ' ')
  if [ "$filesize" -gt "$MAX_FILE_SIZE_BYTES" ]; then
    echo "[SKIP] File too large (${filesize}B > ${MAX_FILE_SIZE_BYTES}B): $filepath"
    return 1
  fi

  if [ "$filesize" -eq 0 ]; then
    echo "[SKIP] File is empty: $filepath"
  fi

  # Check if it's a binary file using 'file' command if available
  if command -v file &> /dev/null; then
    local mimetype
    mimetype=$(file -b --mime-type "$filepath")
    local is_text_mime=false
    case "$mimetype" in
      text/* | application/json | application/ld+json | \
      application/javascript | application/ecmascript | \
      application/xml | image/svg+xml | \
      application/x-sh | application/x-shellscript | \
      application/x-tcl | application/x-perl | application/x-python | application/x-ruby | \
      application/x-tex | application/rtf | \
      application/yaml | application/toml | \
      application/sql | inode/x-empty)
        is_text_mime=true
        ;;
      application/wasm)
        [[ "$filepath" == *.wat ]] && is_text_mime=true
        ;;
    esac
    if ! $is_text_mime; then
      echo "[SKIP] Likely binary or non-text (MIME: $mimetype): $filepath"
      return 1
    fi
  fi

  echo "--- START FILE: $filepath ---" >> "$OUTPUT_FILE"
  cat "$filepath" >> "$OUTPUT_FILE"
  echo "" >> "$OUTPUT_FILE"
  echo "--- END FILE: $filepath ---" >> "$OUTPUT_FILE"
  echo -e "\n" >> "$OUTPUT_FILE"
  echo "[ADDED] $filepath"
  return 0
}

# --- Main Script ---

# Ensure we're in a Tauri project root
if [ ! -f "src-tauri/tauri.conf.json" ]; then
  echo "[ERROR] 'src-tauri/tauri.conf.json' not found."
  echo "Please run this script from the root directory of your Tauri project."
  exit 1
fi

# Initialize output file with a warning header
cat << EOF > "$OUTPUT_FILE"
LLM CONTEXT FILE FOR TAURI PROJECT
GENERATED BY SCRIPT ON: $(date)

IMPORTANT: This file contains concatenated source code from the project.
Review it carefully for any sensitive information (API keys, passwords,
confidential algorithms, personal data, etc.) BEFORE sharing it with any
Large Language Model or third party.

EOF

echo "[INFO] Generating LLM context file: $OUTPUT_FILE"

# 1. Key configuration files
echo "[INFO] Processing key configuration files..."
KEY_CONFIG_FILES=(
  "README.md" "README.txt" "readme.md"
  "package.json"
  "vite.config.js" "vite.config.ts" "vite.config.mjs"
  "webpack.config.js" "webpack.config.ts"
  "svelte.config.js"
  "next.config.js" "next.config.mjs"
  "nuxt.config.js" "nuxt.config.ts"
  "angular.json"
  "vue.config.js"
  "tsconfig.json" "jsconfig.json"
  "postcss.config.js" "tailwind.config.js" "tailwind.config.ts"
  ".env.example" ".env.sample"
  "src-tauri/tauri.conf.json"
  "src-tauri/Cargo.toml"
  "src-tauri/build.rs"
)

for f in "${KEY_CONFIG_FILES[@]}"; do
  [ -f "$f" ] && add_file_content "$f"
done

# 2. Rust source files
echo "[INFO] Processing Rust backend source files (src-tauri/src)..."
find src-tauri/src -type f -name "*.rs" -print0 | while IFS= read -r -d $'\0' file; do
  add_file_content "$file"
done

# 3. Frontend source files
echo "[INFO] Processing frontend source files..."

FILE_PATTERNS_TO_INCLUDE=(
  "*.html" "*.htm"
  "*.css" "*.scss" "*.sass" "*.less" "*.pcss" "*.postcss"
  "*.js" "*.jsx" "*.mjs" "*.cjs"
  "*.ts" "*.tsx" "*.mts" "*.cts"
  "*.vue" "*.svelte"
  "*.md" "*.json" "*.xml" "*.yaml" "*.yml" "*.toml"
  "*.svg"
  "*.sh" "*.bash"
  "*.graphql" "*.gql"
  "*.wat"
  "*.glsl" "*.frag" "*.vert" "*.txt"
)

FRONTEND_DIRS_TO_SEARCH=(
  "." "src" "app"
  "components" "ui"
  "pages" "views" "routes"
  "layouts"
  "lib" "utils" "services" "store"
  "styles" "css" "scss"
  "assets" "public" "static"
  "src/app" "src/routes"
  "src/components" "src/ui"
  "src/pages" "src/views"
  "src/layouts"
  "src/lib" "src/utils" "src/services" "src/store"
  "src/styles" "src/assets"
)

EXCLUDE_PATH_PREFIXES=(
  "./node_modules/"
  "./.git/" "./dist/" "./build/" "./out/"
  "./target/" "./src-tauri/target/"
  "./.tauri/" "./.vscode/" "./.idea/" "./.fleet/"
  "./__pycache__/" "./.DS_Store"
  "./$OUTPUT_FILE"
)

PROCESSED_FILES_CANONICAL=()

for search_dir in "${FRONTEND_DIRS_TO_SEARCH[@]}"; do
  [ ! -d "$search_dir" ] && continue
  echo "[INFO] Searching in '$search_dir' directory..."

  find_args=("$search_dir")
  [ "$search_dir" == "." ] && find_args+=("-maxdepth" "1") || find_args+=("-maxdepth" "10")
  find_args+=("-type" "f" "(")

  first_pattern=true
  for pattern in "${FILE_PATTERNS_TO_INCLUDE[@]}"; do
    $first_pattern || find_args+=("-o")
    find_args+=("-iname" "$pattern")
    first_pattern=false
  done
  find_args+=(")" "-print0")

  find "${find_args[@]}" 2>/dev/null | while IFS= read -r -d $'\0' found_file; do
    normalized_found_file="${found_file#./}"

    is_excluded=false
    for exclude_prefix in "${EXCLUDE_PATH_PREFIXES[@]}"; do
      normalized_exclude_prefix="${exclude_prefix#./}"
      [[ "$normalized_found_file" == "$normalized_exclude_prefix"* ]] && is_excluded=true && break
    done
    $is_excluded && continue

    canonical_file_path=$(realpath "$found_file" 2>/dev/null)
    [ -z "$canonical_file_path" ] && canonical_file_path="$normalized_found_file"

    skip_duplicate=false
    for processed_path in "${PROCESSED_FILES_CANONICAL[@]}"; do
      [[ "$processed_path" == "$canonical_file_path" ]] && skip_duplicate=true && break
    done
    $skip_duplicate && continue

    if add_file_content "$found_file"; then
      PROCESSED_FILES_CANONICAL+=("$canonical_file_path")
    fi
  done
done

# --- Finalization ---
echo ""
TOTAL_LINES=$(wc -l < "$OUTPUT_FILE" | tr -d ' ')
TOTAL_SIZE=$(du -h "$OUTPUT_FILE" | cut -f1)

echo "[SUCCESS] LLM context file '$OUTPUT_FILE' generated."
echo "  Total lines: $TOTAL_LINES"
echo "  Total size: $TOTAL_SIZE"
echo ""
echo "[IMPORTANT REMINDER]"
echo "Please carefully review '$OUTPUT_FILE' and REMOVE any sensitive information"
echo "(API keys, passwords, personal data, proprietary code not meant for sharing, etc.)"
echo "BEFORE using
